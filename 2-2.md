# Februrary - Week 2

## Progress

- set up build environment
- realized build environment is very non-portable

### Plans

- define our own trap entry so we are not relying on compiler
  - mimic riscv-tests in how they do this
  - nested interrupt stuff -- make sure that interrupts are disabled while we
    are pushing/popping interrupts from the stack
- for me, rewire the entirity of boot... 
  - delete the part of `vm_boot` that Will told me to delete

Eileen 
- creating simple pre-loaded scheduler framework thing 

Henry 
- ecall framewor

Amber
- boot rewrite with TB core, linker, etc

### Realizations for the Far Future

- because of the way `riscvtests` is wired to the simulation, if we want to
  have the primary environment mimic the verification tests, we'll have to
  completely rewrite the library (eg `string.c`) because the way it outputs to
  `tohost` is completely different then the way the in-house tests output to
  `tohost`

## Questions to ask

General
- how does stuff like add.S test the actual virtual memory implementation?

Cole
- what did u hack into riscvtests lol
- why use `attribute((interrupt))` for the verification tests if that's
  compiler-dependent, rather than defining your own trap entry handler so you
  have more control 
- `attribute((interrupt))` only seems to handle mret within the compiler, rather
  than sret -- how did you account for that

Will
- format of testbench
- how tohost works

## 2/10

### TB format

`RISCVBusiness/tb_core.cc`

This is the standin for the core interfacing with the rest of the chip
(AFT-dev).

- verilator compiles the system verilog into cpp
- it object-orients the DUT (the core) so that it can alter what's going inside
  the DUT--for example, editing mtime, wdata, addr inside the dut by doing
  dut.addr
- within the RVB core's address space, there's `tohost`, which is used to
  write/read to the testbench. Tohost is cacheable, which is why it needs to be
  fenced.

What Cole did to `riscvtests`

- Cole hacked the testbench core to read the elf of the bin path to teh test
  bench in `riscvtests`, which is why the .tohost region exists in the
  `riscvtests` linker

Verification tests vs `riscvtests`
- `.tohost` is defined as `0x80001040` in `riscv_tests` environment
- `.tohost` is defined as `0` in the verification environment
- Within the verification tests:
  - when start.S jumps to done, it loads the flag into `0x28` register, which
    is the register used to communicate with the testbench
  - in `tb_core.cc`, line 424, we can see that it compares the flag value
    (expected 1 for a pass) using `!use_tohost && dut.top_core->get_x28() == 1`
  - this is also why we dont need `.tohost` to be the actual tohost address in
    the verification tests; it's not used

Printing in simulation 
- `MAGIC_ADDR` is `0xFFFFFFFC` and is defined in both `tb_core` and
  `utility.h`. The print library is wired to print to that address in the
  verification tests.
- Line `152` in `tb_core.cc` is where the testbench checks to writes at that
  address, and if writes exist, it prints to stdout.
- In `riscvtests`, print (putc) writes to `tohost` in a different system.

### Trap format

In `riscvtests`, a custom trap entry format is specified
- this is not the case with the verification tests, which use
  `__attribute((interrupt))` and rely on the compiler
- it may not be the best choice to rely on the compiler, so we will do like the
  riscv-tests do

Flow of control:
1) trap_entry
2) jump to trap handlera delegator
3) jump to correct trap handler based on scause

### Linker Script

ENTRY
- `rvt`: `_start`
- `ver`: `boot`
- start here to start editing differences

MEMORY START
- same place `0x80000000`
- use the `ver` of this

.TOHOST
- defined as a specific section of memory in `rvt`
- can probably nerf; or at least move to `0xFFFFFFFC` because that becomes I/O
  for the verification tests

ALIGN in `rvt`
- tohost, .text, and .text.init are both aligned to `0x1000`
- align moves the location ctr fowards to the next multiple of 4096 (page size)

TEXT
- `rvt`: contains .text.init and .text
- `ver`: contains .text.boot and .text
- seems that the only stuff in start.S / entry.S is .init/.boot; figure out how
  the rest of the .binfile programs are linked into .text (if at all)

DATA
- `rvt`: everythign in .data
- `ver`: .data, .rodata (i doubt this is actually read-only, it's probably
  writeable), .sdata (?), .eh_frame

BSS
- `rvt`: .bss
- `ver`: .sbss and .bss

what's preinit_arr and init_arr for? 
- both fucntiosn are arrays of function ptrs that the startup code calls before
  main() 
- libc bootstrap logic, hooks, c global initialization code (eg putting .data
  where it needs to be put)
- if we have pure assembly code, the startup code just skips them and continues
  to main. if \__init_array_start == \__init_array_end, the init array loop
  never runs.
  - no object file will ever provide the .init_array (?) 

currently, `rvt`: 
- .text.init starts at `RAM`
- .tohost starts at new 4KB page
- .text starts at new 4KB page
- .data starts o na new 4KB page

I think I just need to make sure that things align well and each section is
page-separated

## Raw Meeting Notes

Tohost

RVB <-> TestBench 

Signal connected between teh test bench and teh actual core itself 
- One of them being the address, wdata…

Within the RVB’s address space, there’s something called tohost
- Its an address specifying we want to write something to the test bench
- Tohost currently is cacheable which s why they have to fence it


Test bench
- At all points in time, monitors what the core does
- Any address that it reads
- If a spa


Test bench
- $RISCV_CORE: path to ventilator build

Cole ..
- Reads the elf of the specified path to the test bench in riscvtests, and then the takes the those region within the  riscvtests and u read it in run_test.py

When u build the riscv processor, it will create an executable with vtop_core, and this is what u use to run the inary that you’re tryna run. 

- In Rvb, tb_core.cc

Register 28 or sumn with test bench

Within the verification tests. Start.S jumps to done, and loads the value of flag into x28!! 
- In tb_core.cc: in the main loop, checks rte core, program runs in the while loop…. It verifies correctness, and if we are not using those && dut.top_core line 424
- There’s two things here : the first one is using those —- specifying that it is a test that RISCV corp has written, and reading the those address — whatever is defined within the test for that elf —> if its .. see if x28 is 

Non-cacheable region
- Anything from 0XF0000 _> onwards is non-cacheable 

How does print work within the simulation 
- Cole’s method: writing directly to 0XFFFFFFFC within the verificication tests 
- #define MAGIC_ADDR in utility.h
- In test bench we have the same magic address defined 
- 153 line 

How do we build a cc file into system verilog? 
- Include the ventilator files 
- vtop_core.h create a class — essentially — for our module — so when we define our class, we just give it a DUT pointer, and is just a pointer to a class where (dut_ptr) where we can control the ptr, and those r all inputs and outputs for the core 
- Converts system verilog to cpp so that it runs 

Mie 
- Enable interrupts for whatever interrupts it specifies
MIP
- For pending interrupts 

MIP
- Different bits, and each goes to sumn (machine timer, machine software…) and it does htehse for hte other modes.. they can alternate
- The spec defines priority 

Nested interrupts
- We can take nested interrupts cz we can offload registers onto the stack, but that’s not set up anywhere 

Say we r in a s-mode interrupt handler and a m-mode interrupt happens; 
- priv_in_ex_handler.sv gives priority handling stuff 
- In line 32 — m-mode interrupt take sprioirty over what’s going on currently 

Trap handler
- Between the time it takes for the trap handler to push everything onto the stack and it actually df

trap_entry
- Puts sumn onto the stack
- Puts all the store words
- Jumps to handle_trap 
- Goes to different handle_trap
- Looks at hte cause of the trap

In the riscv corporation traps, they dont have the __attribute__
- They do sumn stufff with the scratch registers…. 

Do it in the riscv corporation way 
- We wont have to rely on the compiler to do it for us

So recomended flow: 
1. trap_entry
2. J handle_trap
3. 


